#Node.js运行机制解析
 
   > 当我们搜索Node.js时，夺眶而出的关键字就是 "单线程，异步I/O，事件驱动"，应用程序的请求过程可以分为俩个部分：CPU运算和I/O读写，CPU计算速度通常远高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后再继续接下来的业务。
 
   >所以I/O才是应用程序的瓶颈所在，在I/O密集型业务中，假设请求需要100ms来完成，其中99ms化在I/O上。如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启100个、1000个线程来提高我们请求处理，当然这也是一种可观的方案。
 
   >但是由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源。但操作系统在内核切换线程的同时也要切换线程的上线文，当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。
   
##nodejs单线程
   ![](http://articles.csdn.net/uploads/allimg/160712/1QP361F-20.jpg)
>Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。

##nodejs事件驱动
![](http://articles.csdn.net/uploads/allimg/160712/1QP33934-21.jpg)
>I/O操作完之后呢？Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。
 
 
 
>&ensp;&ensp;本了解了异步I/O、单线程、事件驱动这几个Node的标签，这里再引入一个观察者的概念，每次轮询都会去向观察者询问是否有事件需要处理，这个过程就如同饭馆的后厨，厨房一轮一轮的制作菜肴，具体做什么菜取决于餐厅里客人的下单，厨房做完成就询问收银小妹接下来做什么菜，而收银小妹就是观察者，他收到的客人点单就是关联的回调函数，如果生意好的饭馆会有多个收银小妹，就如同事件循环中有多个观察者，收到下单就是一个事件，一个观察者里头可能有多个事件。
 
>&ensp;&ensp;在node.js中，事件主要来源于网络请求，文件I/O等，根据事件的不同对观察者进行了分类，有文件I/O观察者，网络I/O观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行I/O等待。
 
>&ensp;&ensp;那么您可能会问，这种单个线程进行运算，对于多核CPU的服务器岂不是英雄无用武之地，还有就是当主线程业务运算超时，岂不是来不及处理事件队列里（观察者里头）的事件？
 
>&ensp;&ensp;对于这俩个问题，首先要做的一点就是在代码编写的时候尽量避免耗时的计算，将大计算进行拆分，这样能够让主线程及时得到释放，处理消费事件队列里头的事件。其次，node.js提供了child_process模块开启子进程，理想状态下每个进程各自利用一个CPU，以此实现多核的利用，child_precess提供创建子进程，以及进程状态监控，进程之间通信的API，感兴趣的小伙伴可以问问度娘，或者欢迎私聊。
 
>&ensp;&ensp;聊到这里，我们就可以回顾前面的问题，为什么在有PHP、Java、DotNet的今天我们还会去选择Node.js，因为它的单线程、异步I/O、事件驱动特点能够更好的处理I/O密集型的业务场景，同时它在多核CPU利用上面也做的非常优秀，这就是他存在的理由！
 
>&ensp;&ensp;当然，如果你的业务场景几乎没有任何I/O操作，属于纯CPU密集型的业务，那最好还是选择一种多线程语言。
 
##一个Node.js饭店的发展历程
 
    前面的一堆理论似乎不太好明白，最后讲一个关于饭店发展历程的故事作为结尾吧。
 
###第一年

*   饭店开张，只有一个厨师（同时还兼任老板、服务员、打荷、收银员），当一个客人点餐之后，这个厨师就开始记录（服务员），然后他就开始备菜（打荷）、炒菜（厨师）、然后上菜（服务员）、收钱（收银员），这个时候即使有其他客人来了，等着吧还没忙完呢。这个厨师就这样兢兢业业，有条不紊的干着每一件事，因为每件事都是亲力亲为，都不能出错，虽然所有的事情都了然于心，但效率很低，一天只能卖出十多份饭菜。
    这是饭店单线程的第一年：
 
    利：它没有线程上下文交换所带来性能上的开销（因为每件事都是亲力亲为）；
 
    弊：无法利用多核CPU（厨房空间那么大，完全可以很多人一起干活），同时错误会引起整个应用退出，应用的健壮性值得考验（当这个厨师生病，或者有事了饭店就得停业）
 
###第二年
 
*   这个厨师第一年赚了点钱，回到老家把表哥、表弟全拉过来，现在他们有5个人，可工作方式还是跟厨师第一年的时候一样。当客人来了，就会有一个人去记录，然后自己去厨房洗菜、切菜、炒菜、洗碗、上菜、收钱。当来了第六个客人的时候，就要等待前面的人做完所有事情才能空出一个人来接待。后来他们就想既然客户多了，厨师就得多，再回老家多叫几个兄弟吧。这时新的问题发生了，当每个厨师做完饭后就出去找客人，客人说我刚刚点餐了，然后厨师就去厨房问，刚刚是哪个表兄接待的那个客户，要是没有人接待的话，我来处理。就这样忙忙碌碌一年，他们比去年多做了好多生意，但是感觉每天客户多的时候，厨房里头乱糟糟的，总要询问这个询问那个。
 
    这就是饭店多线程的一年：
 
    利：一个线程服务一个请求，线程之间可以共享数据，这样可以避免内存的浪费，可以同时处理多个请求；
 
    弊：操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被消耗在上下文切换上（厨房里头乱糟糟的，总要询问这个询问那个）。
 
### 第三年
*   老板娘过来了（Node.Js闪亮登场），她发现这帮厨师都在各自为战，自己拿到客户的点餐后去洗菜、切菜、洗碗、炒菜、上菜、收钱，一个人只能同时处理一个任务，而且作为厨师没必要去做洗菜、切菜、洗碗、收银之类费时的工作。
 
    所以老板娘把所有人进行了分工：
 
    老板作为厨师长（Node里头的主线程），他不再去洗碗、洗菜、切菜、炒菜、收银（我们可以把洗碗、洗菜、炒菜、切菜认为是比较耗时的I/O），他只负责将收银台小妹（观察者）拿过来的菜单分配给不同的厨师，打荷（这些人就是不同的I/O线程），吩咐下去之后他不会等菜出来再走（进入下一个轮询），又问收银台小妹还有没有菜单要做，如果有继续轮询，如果没有了休息（退出进程）。当菜做出来之后放在上菜区（回调），收银台就显示菜出来了（将回调放入事件队列），当老板查询收银员（观察者）的时候，收银员就告诉厨师长，厨师长就通知服务员（处理不同I/O的线程）上菜（完成回调），这样饭店有条不紊的运行下去，客人也越来越多了。
 
    有些高端客户不想在这挤，所以老板娘就想，饭店房子那么大（多核CPU）,可以叫她弟弟（子进程的主线程）在这开个子店（child_process），然后发现一个收银员不够用，那就多招几个收银员（多个观察者），就这样每个分店（进程）只有一个主管（主线程），主管的弱点就是无暇顾及洗碗等杂活（I/O），只能关注业务，至于饭店能开多大（应用程序能处理多大请求），要看主管的处理能力（主线程的编程强壮度）。最后，大饭店起了个时髦的名字叫Hotel NodeJs！
 
    希望这个小故事能够给大家对Node.Js运行的理解带来一点帮助，谢谢。
 
